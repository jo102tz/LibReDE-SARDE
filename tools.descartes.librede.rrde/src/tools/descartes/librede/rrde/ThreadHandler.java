package tools.descartes.librede.rrde;

import java.util.Collection;

import org.apache.log4j.Logger;

import tools.descartes.librede.configuration.EstimationSpecification;
import tools.descartes.librede.configuration.LibredeConfiguration;
import tools.descartes.librede.rrde.lifecycle.LifeCycleConfiguration;
import tools.descartes.librede.rrde.optimization.OptimizationConfiguration;
import tools.descartes.librede.rrde.recommendation.RecommendationTrainingConfiguration;
import tools.descartes.librede.rrde.recommendation.algorithm.IRecomendationAlgorithm;
import tools.descartes.librede.rrde.test.TestCombination;

/**
 * This class handles the online scenario of librede.
 * It schedules the different calculations that have to be done
 * cyclic.
 * 
 * @author Torsten Krau√ü
 *
 */
public class ThreadHandler extends Thread {

	/**
	 * The logger used for logging
	 */
	private static final Logger log = Logger.getLogger(ThreadHandler.class);

	/**
	 * The thread instances of the online scenario.
	 */
	private OptimizationThread optimizationThread;
	private RecommendationThread recommendationThread;
	private SelectionThread selectionThread;
	private EstimationThread calculationThread;
	/**
	 * The different configurations.
	 */
	private LifeCycleConfiguration lifeCycleConfiguration;
	private OptimizationConfiguration optimizationConfiguration;
	private RecommendationTrainingConfiguration recommendationTrainingConfiguration;
	private LibredeConfiguration libredeConfiguration;
	/**
	 * The results of the different calculations
	 */
	private Collection<EstimationSpecification> newEstimationSpecifications;
	private Collection<EstimationSpecification> actualEstimationSpecifications;
	private IRecomendationAlgorithm newRecommendationAlgorithm;
	private IRecomendationAlgorithm actualRecommendationAlgorithm;
	private EstimationSpecification newEstimationSpecification;
	private EstimationSpecification actualEstimationSpecification;
	/**
	 * The timestamps for the next executions of the other Threads
	 */
	private long nextExecutionTimeStampOptimization;
	private long nextExecutionTimeStampRecommendation;
	private long nextExecutionTimeStampSelection;
	private long nextExecutionTimeStampEstimation;
	/**
	 * Life cycle helpers of this thread.
	 */
	private boolean isInitialized;
	private volatile boolean stop;
	/**
	 * The constructor of this class.
	 * @param lifeCycleConfiguration
	 */
	public ThreadHandler(LifeCycleConfiguration lifeCycleConfiguration) {
		log.info("Create ThreadHandler instance...");
		this.lifeCycleConfiguration = lifeCycleConfiguration;
		this.isInitialized = false;
		this.stop = false;
		log.info("ThreadHandler instance created!");
	}
	
	public void terminate() {
		log.info("Initialize termination of ThreadHandler instance!");
		this.stop = true;
	}
	
	/**
	 * OPTIMIZATION THREAD RESULTS--------------------------------------------------
	 */
	
	/**
	 * Sets the new EstimationSpecifications calculated from the Optimization
	 * Thread the next data for the Recommendation Thread
	 * @param newData
	 */
	public void setNewEstimationSpecifications(
			Collection<EstimationSpecification> newData) {
		synchronized (this.newEstimationSpecifications) {
			this.newEstimationSpecifications = newData;
			log.info("New Estimation Specification stored!");
		}
	}
	/**
	 * Returns the actual newest List of EstimationSpecifications from the Optimization
	 * Thread. This method is intended to deliver the data to the Recommendation Thread.
	 * @return
	 */
	public Collection<EstimationSpecification> getActualEstimationSpecifications() {
		synchronized (this.newEstimationSpecifications) {
			if(this.newEstimationSpecifications!=null){
				this.actualEstimationSpecifications = this.newEstimationSpecifications;
				this.optimizationConfiguration = null;
				log.info("Actual Estimation Specification updated!");
			}
			log.info("Actual Estimation Specification returned.");
			return actualEstimationSpecifications;
		}
	}
	/**
	 * -----------------------------------------------------------------------------
	 */
	
	/**
	 * RECOMMENDATION THREAD RESULTS--------------------------------------------------
	 */
	/**
	 * This method sets the new results of the Recommendation Thread.
	 * 
	 * @param newRecommendationAlgorithm
	 */
	public void setNewRecommendationAlgorithm(IRecomendationAlgorithm newRecommendationAlgorithm) {
		synchronized (this.newRecommendationAlgorithm) {
			this.newRecommendationAlgorithm = newRecommendationAlgorithm;
			log.info("New Recommendation Algorithm stored!");
		}
	}
	/**
	 * This method returns the actual newest Algorithm generated by the Recommendation
	 * Thread. It is intended to deliver the Algorithm to the Selector Thread.
	 * 
	 * @return
	 */
	public IRecomendationAlgorithm getActualRecommendationAlgorithm() {
		synchronized (this.newRecommendationAlgorithm) {
			if(this.newRecommendationAlgorithm!=null){
				this.actualRecommendationAlgorithm = this. newRecommendationAlgorithm;
				this.newRecommendationAlgorithm = null;
				log.info("Actual Recommendation Algorithm updated!");
			}
			log.info("Actual Recommendation Algorithm returned.");
			return this.actualRecommendationAlgorithm;
		}
	}
	/**
	 * -----------------------------------------------------------------------------
	 */
	/**
	 * SELECTION THREAD RESULTS-----------------------------------------------------
	 */
	/**
	 * This method sets the new results of the Selection Thread.
	 * 
	 * @param newRecommendationAlgorithm
	 */
	public void setNewEstimationSpecification(EstimationSpecification newEstimationSpecification) {
		synchronized (this.newEstimationSpecification) {
			this.newEstimationSpecification = newEstimationSpecification;
			log.info("New Estimation Specification stored!");
		}
	}
	/**
	 * This method returns the actual newest Estimation Specification generated by the
	 * Selection Thread. It is intended to deliver the Specification to the Estimation Thread.
	 * 
	 * @return
	 */
	public EstimationSpecification getActualEstimationSpecification() {
		synchronized (this.newEstimationSpecification) {
			if(this.newEstimationSpecification!=null){
				this.actualEstimationSpecification = this.newEstimationSpecification;
				this.newEstimationSpecification = null;
				log.info("Actual Estimation Specification updated!");
			}
			log.info("Actual Estimation Specification returned.");
			return actualEstimationSpecification;
			
		}
	}
	/**
	 * -----------------------------------------------------------------------------
	 */
	@Override
	public void run() {
		if(!isInitialized){
			//initialize the thread here
			log.info("Initializing ThreadHandler...");
			this.optimizationThread = new OptimizationThread(this,null,null,null);
			this.recommendationThread = new RecommendationThread(this, null);
			this.selectionThread = new SelectionThread(this, null, null, null);
			this.calculationThread = new EstimationThread(this,null);
			log.info("ThreadHandler initialized!");
		}
		log.info("ThreadHandler starts looping...");
		//run until stopped
		while(!stop){
			//start the workerthread, if it is not still working
			
		}
		log.info("ThreadHandler looping stopped!");
	}
}
